import sys, os, shutil, zipfile, tempfile, zlib, struct, json, base64, hashlib, traceback, time, subprocess, re
from pathlib import Path
from io import BytesIO
from typing import List, Optional, Tuple, Dict, Any
import threading

# Qt binding: prefer PyQt5 then PySide6
try:
    from PyQt5 import QtCore, QtGui, QtWidgets
    from PyQt5.QtCore import QObject, QThread, pyqtSignal as Signal, Qt, QSize
    from PyQt5.QtGui import QPixmap, QIcon
    from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                                 QPushButton, QFileDialog, QListWidget, QListWidgetItem, QLabel,
                                 QComboBox, QProgressBar, QTextEdit, QLineEdit, QMessageBox,
                                 QInputDialog, QStyle, QFileIconProvider, QCheckBox, QSpinBox, QRadioButton, QSizePolicy)
    QT_BINDING = "PyQt5"
except Exception:
    from PySide6 import QtCore, QtGui, QtWidgets
    from PySide6.QtCore import QObject, QThread, Signal, Qt, QSize
    from PySide6.QtGui import QPixmap, QIcon
    from PySide6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                                   QPushButton, QFileDialog, QListWidget, QListWidgetItem, QLabel,
                                   QComboBox, QProgressBar, QTextEdit, QLineEdit, QMessageBox,
                                   QInputDialog, QStyle, QFileIconProvider, QCheckBox, QSpinBox, QRadioButton, QSizePolicy)
    QT_BINDING = "PySide6"

# optional libs
try:
    import py7zr; HAS_PY7ZR = True
except Exception:
    HAS_PY7ZR = False
try:
    import rarfile; HAS_RARFILE = True
except Exception:
    HAS_RARFILE = False
try:
    import pyzipper; HAS_PYZIPPER = True
except Exception:
    HAS_PYZIPPER = False
try:
    from PIL import Image
    HAS_PIL = True
except Exception:
    HAS_PIL = False

# Windows registry helper (for association)
ON_WINDOWS = sys.platform.startswith("win")
if ON_WINDOWS:
    try:
        import winreg
    except Exception:
        winreg = None

# ---------- config & caches ----------
def cfg_path() -> Path:
    if sys.platform.startswith("win"):
        return Path(os.getenv("APPDATA") or Path.home()) / "miniarch_cfg.json"
    return Path.home() / ".miniarch_cfg.json"

CFG_FILE = cfg_path()
def load_cfg() -> dict:
    try:
        if CFG_FILE.exists():
            return json.loads(CFG_FILE.read_text(encoding="utf-8"))
    except Exception:
        pass
    return {}

def save_cfg(cfg: dict):
    try:
        CFG_FILE.parent.mkdir(parents=True, exist_ok=True)
        CFG_FILE.write_text(json.dumps(cfg, indent=2), encoding="utf-8")
    except Exception:
        pass

CFG = load_cfg()

def thumb_cache_dir() -> Path:
    if ON_WINDOWS:
        base = Path(os.getenv("APPDATA") or Path.home())
    else:
        base = Path.home()
    d = base / "miniarch_thumbs"
    d.mkdir(parents=True, exist_ok=True)
    (d / "icon_probes").mkdir(parents=True, exist_ok=True)
    return d

THUMB_CACHE = thumb_cache_dir()
IMAGE_EXTS = {'.png', '.jpg', '.jpeg', '.bmp', '.gif', '.webp', '.tif', '.tiff'}
THUMB_SIZE = (128, 128)

# ---------- JARC helpers ----------
JARC_MAGIC = b"JARC"
JARC_FOOTER = b"JARCEOF"

def create_jarc(out_path: str, inputs: List[str], compress: bool = True):
    entries = []
    files = []
    for p in inputs:
        pth = Path(p)
        if not pth.exists():
            continue
        if pth.is_dir():
            parent = pth.parent
            for root, _, fnames in os.walk(pth):
                for f in fnames:
                    full = Path(root) / f
                    arc = full.relative_to(parent)
                    files.append((str(full), str(arc).replace("\\", "/")))
        else:
            files.append((str(pth), pth.name))
    with open(out_path, "wb") as f:
        f.write(JARC_MAGIC); f.write(b'\x01')
        for full, arc in files:
            off = f.tell()
            with open(full, "rb") as rf:
                data = rf.read()
            if compress:
                stored = zlib.compress(data); compressed = True
            else:
                stored = data; compressed = False
            f.write(stored)
            entries.append({"name": arc, "offset": off, "size": len(stored), "compressed": compressed})
        manifest = json.dumps(entries, ensure_ascii=False).encode("utf-8")
        f.write(manifest)
        f.write(struct.pack("<Q", len(manifest)))
        f.write(JARC_FOOTER)

def read_jarc_manifest(path: str):
    with open(path, "rb") as f:
        if f.read(4) != JARC_MAGIC:
            raise RuntimeError("Not a JARC")
        f.read(1)
        f.seek(0, os.SEEK_END)
        fs = f.tell()
        flen = len(JARC_FOOTER)
        f.seek(fs - (flen + 8))
        manifest_len = struct.unpack("<Q", f.read(8))[0]
        footer = f.read(flen)
        if footer != JARC_FOOTER:
            raise RuntimeError("JARC footer missing")
        start = fs - (flen + 8) - manifest_len
        f.seek(start)
        entries = json.loads(f.read(manifest_len).decode("utf-8"))
        return entries

def extract_jarc_member_bytes(path: str, entry_name: str) -> bytes:
    entries = read_jarc_manifest(path)
    for e in entries:
        if e["name"] == entry_name:
            with open(path, "rb") as f:
                f.seek(e["offset"]); b = f.read(e["size"]); return zlib.decompress(b) if e.get("compressed") else b
    raise KeyError("entry not found")

# ---------- subprocess helper ----------
def safe_run(cmd: List[str], timeout: int = 600, cwd: Optional[str] = None) -> Tuple[int, bytes, bytes]:
    creationflags = getattr(subprocess, "CREATE_NO_WINDOW", 0)
    try:
        proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                              check=False, creationflags=creationflags, timeout=timeout, cwd=cwd)
        return proc.returncode, proc.stdout, proc.stderr
    except subprocess.TimeoutExpired:
        return -1, b"", b"timeout"
    except Exception as e:
        return -2, b"", str(e).encode()

# ---------- system icons ----------
_icon_cache: Dict[str, QIcon] = {}
def get_system_icon_for_ext(ext: str) -> QIcon:
    ext = (ext or ".txt").lower()
    if not ext.startswith('.'): ext = '.' + ext
    if ext in _icon_cache:
        return _icon_cache[ext]
    try:
        probe = THUMB_CACHE / "icon_probes" / ("dummy" + ext)
        if not probe.exists():
            try:
                probe.write_bytes(b"")
            except Exception:
                pass
        provider = QFileIconProvider()
        qfi = QtCore.QFileInfo(str(probe))
        icon = provider.icon(qfi)
        if icon.isNull():
            icon = QApplication.style().standardIcon(QStyle.SP_FileIcon)
    except Exception:
        icon = QApplication.style().standardIcon(QStyle.SP_FileIcon)
    _icon_cache[ext] = icon
    return icon

# ---------- thumbnail helpers ----------
def thumb_cache_key(archive: str, entry: str) -> str:
    try:
        mtime = str(Path(archive).stat().st_mtime)
    except Exception:
        mtime = "0"
    h = hashlib.sha1((archive + '|' + entry + '|' + mtime).encode("utf-8")).hexdigest()
    return h

class ThumbWorker(QObject):
    thumb_ready = Signal(str, str)
    finished = Signal()
    log = Signal(str)
    def __init__(self, archive_path: str, archive_fmt: str, names: List[str], password: Optional[str] = None):
        super().__init__()
        self.archive_path = archive_path
        self.archive_fmt = archive_fmt
        self.names = names[:]
        self.password = password
        self._running = True
    def stop(self): self._running = False
    def run(self):
        try:
            for name in self.names:
                if not self._running:
                    break
                ext = Path(name).suffix.lower()
                if ext not in IMAGE_EXTS:
                    continue
                key = thumb_cache_key(self.archive_path, name)
                cache_file = THUMB_CACHE / (key + ".png")
                if cache_file.exists():
                    self.thumb_ready.emit(name, str(cache_file)); continue
                data = None
                try:
                    if self.archive_fmt == 'zip':
                        with zipfile.ZipFile(self.archive_path, 'r') as zf:
                            cand = None
                            if name in zf.namelist():
                                cand = name
                            else:
                                for nm in zf.namelist():
                                    if Path(nm).name == Path(name).name:
                                        cand = nm; break
                            if cand:
                                data = zf.read(cand)
                    elif self.archive_fmt == '7z' and HAS_PY7ZR:
                        tmpd = Path(tempfile.mkdtemp(prefix="thumb_"))
                        try:
                            with py7zr.SevenZipFile(self.archive_path, 'r', password=(self.password if self.password else None)) as a:
                                try:
                                    a.extract(targets=[name], path=str(tmpd))
                                except Exception:
                                    try:
                                        a.extractall(path=str(tmpd))
                                    except Exception:
                                        pass
                                cand = tmpd / name
                                if cand.exists():
                                    data = cand.read_bytes()
                                else:
                                    for p in tmpd.rglob("*"):
                                        if p.is_file() and p.name == Path(name).name:
                                            data = p.read_bytes(); break
                        finally:
                            shutil.rmtree(str(tmpd), ignore_errors=True)
                    elif self.archive_fmt == 'rar' and HAS_RARFILE:
                        try:
                            with rarfile.RarFile(self.archive_path) as rf:
                                target = None
                                for nm in rf.namelist():
                                    if nm == name or Path(nm).name == Path(name).name:
                                        target = nm; break
                                if target:
                                    with rf.open(target) as fh:
                                        data = fh.read()
                        except Exception:
                            data = None
                    elif self.archive_fmt == 'jarc':
                        try:
                            data = extract_jarc_member_bytes(self.archive_path, name)
                        except Exception:
                            data = None
                except Exception as e:
                    self.log.emit(f"thumb extract error {name}: {e}")
                    data = None

                if not data:
                    continue

                try:
                    cache_file.parent.mkdir(parents=True, exist_ok=True)
                    if HAS_PIL:
                        img = Image.open(BytesIO(data)).convert("RGBA")
                        img.thumbnail(THUMB_SIZE, Image.LANCZOS)
                        img.save(str(cache_file), format="PNG")
                    else:
                        cache_file.write_bytes(data)
                    self.thumb_ready.emit(name, str(cache_file))
                except Exception as e:
                    self.log.emit(f"thumb save error {name}: {e}")
                QtCore.QThread.msleep(20)
        except Exception as e:
            self.log.emit("thumbworker crash: " + str(e) + "\n" + traceback.format_exc())
        finally:
            self.finished.emit()

# ---------- Par2 manager (grouping logic kept) ----------
class Par2Signals(QObject):
    log = Signal(str)
    progress = Signal(int, int)
    finished = Signal(dict)

class Par2Manager:
    def __init__(self, par2_exe: Optional[str] = None, per_file_timeout: int = 600):
        self.par2_exe = par2_exe or CFG.get("par2_exe") or shutil.which("par2") or shutil.which("par2.exe")
        self.timeout = per_file_timeout
        self.signals = Par2Signals()
        self._thread = None
        self._stop_flag = False
        self.logpath = Path(os.getenv("APPDATA") or Path.home()) / "miniarch_par2.log"

    def is_ok(self) -> bool:
        return bool(self.par2_exe and Path(self.par2_exe).exists())

    def _append_log(self, text: str):
        try:
            self.logpath.parent.mkdir(parents=True, exist_ok=True)
            with self.logpath.open("a", encoding="utf-8", errors="ignore") as f:
                f.write(text + "\n")
        except Exception:
            pass

    def _try_par2_repair_cmds(self, par2file: str, cwd: Optional[str]) -> Tuple[int, str, str]:
        cmd_variants = [
            [self.par2_exe, "repair", par2file],
            [self.par2_exe, "r", par2file],
            [self.par2_exe, "fix", par2file],
        ]
        last_rc = -999
        last_out = b""; last_err = b""
        for cmd in cmd_variants:
            try:
                self.signals.log.emit(f"Trying: {' '.join(cmd)} (cwd={cwd})")
                rc, outb, errb = safe_run(cmd, timeout=self.timeout, cwd=cwd)
                last_rc, last_out, last_err = rc, outb, errb
                if rc == 0 or outb or errb:
                    return rc, outb.decode(errors="ignore"), errb.decode(errors="ignore")
            except Exception as e:
                last_err = str(e).encode()
                continue
        return last_rc, (last_out.decode(errors="ignore") if isinstance(last_out, bytes) else str(last_out)), (last_err.decode(errors="ignore") if isinstance(last_err, bytes) else str(last_err))

    def _repair_single(self, par2path: str, move_repaired_to: Optional[str] = None) -> Dict:
        res = {"par2": par2path, "rc": None, "out": "", "err": "", "moved": [], "error": None}
        try:
            par2p = Path(par2path)
            if not par2p.exists():
                res["error"] = "par2 not found"
                return res
            workdir = str(par2p.parent)
            before = {}
            for p in par2p.parent.iterdir():
                if p.is_file() and p.suffix.lower() != ".par2":
                    try:
                        before[str(p)] = p.stat().st_mtime
                    except Exception:
                        before[str(p)] = 0.0
            start_time = time.time()
            rc, out, err = self._try_par2_repair_cmds(str(par2p), cwd=workdir)
            res["rc"] = rc; res["out"] = out; res["err"] = err
            moved = []
            try:
                for p in par2p.parent.iterdir():
                    if p.is_file() and p.suffix.lower() != ".par2":
                        try:
                            mtime = p.stat().st_mtime
                        except Exception:
                            mtime = 0
                        if mtime >= start_time - 0.5:
                            if move_repaired_to:
                                dest_dir = Path(move_repaired_to)
                                dest_dir.mkdir(parents=True, exist_ok=True)
                                dest = dest_dir / p.name
                                if dest.exists():
                                    dest = dest_dir / f"{p.stem}_{int(time.time())}{p.suffix}"
                                try:
                                    shutil.move(str(p), str(dest)); moved.append(str(dest))
                                except Exception:
                                    try:
                                        shutil.copy2(str(p), str(dest)); moved.append(str(dest))
                                    except Exception as e:
                                        self.signals.log.emit(f"Could not move repaired file {p}: {e}")
            except Exception as e:
                self.signals.log.emit("post-repair detection error: " + str(e))
            res["moved"] = moved
            if rc is None:
                res["error"] = "par2 not run"
            return res
        except Exception as e:
            res["error"] = str(e)
            self.signals.log.emit("repair_single exception: " + str(e))
            self._append_log(traceback.format_exc())
            return res

    def _create_single(self, files: List[str], redundancy: int, base_name: Optional[str] = None, out_dir: Optional[str] = None) -> Dict:
        res = {"files": files, "rc": None, "out": "", "err": "", "created": [], "error": None}
        try:
            if not files:
                res["error"] = "no files"
                return res
            first = Path(files[0])
            if out_dir:
                workdir = Path(out_dir)
            else:
                workdir = first.parent
            if base_name:
                base = workdir / (base_name + ".par2")
            else:
                base = first.parent / (first.stem + ".par2")
            args_files = []
            for f in files:
                pf = Path(f)
                try:
                    rel = os.path.relpath(str(pf), start=str(workdir))
                    if rel.startswith(".."):
                        args_files.append(str(pf))
                    else:
                        args_files.append(rel)
                except Exception:
                    args_files.append(str(pf))
            cmd = [self.par2_exe, "create", f"-r{redundancy}", str(base)] + args_files
            self.signals.log.emit(f"Running: {' '.join(cmd)} (cwd={workdir})")
            self._append_log(f"{time.strftime('%Y-%m-%d %H:%M:%S')} par2 create: {' '.join(cmd)} cwd={workdir}")
            rc, outb, errb = safe_run(cmd, timeout=self.timeout, cwd=str(workdir))
            res["rc"] = rc; res["out"] = outb.decode(errors="ignore") if outb else ""; res["err"] = errb.decode(errors="ignore") if errb else ""
            created = []
            try:
                stem = base.stem
                for p in set([Path(workdir), base.parent]):
                    for child in p.iterdir():
                        if child.is_file() and child.suffix.lower() == ".par2" and child.stem.startswith(stem):
                            created.append(str(child))
            except Exception:
                pass
            if out_dir:
                moved=[]
                for c in created:
                    src = Path(c); dst = Path(out_dir)/src.name
                    if dst.exists():
                        dst = Path(out_dir)/(src.stem + f"_{int(time.time())}.par2")
                    try:
                        shutil.move(str(src), str(dst)); moved.append(str(dst))
                    except Exception:
                        try:
                            shutil.copy2(str(src), str(dst)); moved.append(str(dst))
                        except Exception:
                            self.signals.log.emit("Failed to move created par2 "+str(src))
                res["created"] = moved
            else:
                res["created"] = created
            if rc!=0 and not res["created"]:
                res["error"] = f"par2 returned rc={rc}"
            return res
        except Exception as e:
            res["error"] = str(e)
            self.signals.log.emit("par2 create exception: "+str(e))
            self._append_log(traceback.format_exc())
            return res

    def _canonical_par2_base(self, filename: str) -> str:
        name = Path(filename).stem
        name = re.sub(r'\.vol\d+\+\d+(?:_\d+)?$', '', name, flags=re.IGNORECASE)
        name = re.sub(r'_\d+$', '', name)
        return name

    def run_repair_many(self, par2_files: List[str], move_repaired_to: Optional[str] = None):
        if self._thread and self._thread.is_alive():
            self.signals.log.emit("Par2Manager: repair already running"); return
        groups_map: Dict[Tuple[str,str], List[str]] = {}
        for p in par2_files:
            pp = Path(p)
            base = self._canonical_par2_base(pp.name)
            key = (str(pp.parent), base)
            groups_map.setdefault(key, []).append(str(pp))
        reps: List[Tuple[str, List[str]]] = []
        for (dirpath, base), files in groups_map.items():
            found_rep = None
            for f in files:
                fn = Path(f).name
                if fn.lower() == f"{base}.par2".lower():
                    found_rep = f; break
            if not found_rep:
                for f in files:
                    if re.match(re.escape(base) + r'_\d+\.par2$', Path(f).name, flags=re.IGNORECASE):
                        found_rep = f; break
            if not found_rep:
                for f in files:
                    if '.vol' not in Path(f).name.lower():
                        found_rep = f; break
            if not found_rep:
                found_rep = files[0]
            reps.append((found_rep, files))
        def worker():
            total = len(reps)
            summary = {"groups": total, "results": []}
            try:
                for idx, (rep, files) in enumerate(reps, start=1):
                    if self._stop_flag:
                        break
                    self.signals.progress.emit(idx, total)
                    self.signals.log.emit(f"Repairing group {idx}/{total} using representative: {rep}")
                    r = self._repair_single(rep, move_repaired_to=move_repaired_to)
                    r["group_members"] = files
                    summary["results"].append(r)
                self.signals.log.emit("par2 repair run complete")
            except Exception as e:
                self.signals.log.emit("par2 repair run exception: " + str(e))
                self._append_log(traceback.format_exc())
            finally:
                self.signals.finished.emit(summary)
        self._stop_flag = False
        self._thread = threading.Thread(target=worker, daemon=True)
        self._thread.start()

    def run_create(self, groups: List[Tuple[List[str], Optional[str], Optional[str]]], redundancy: int, default_out_dir: Optional[str] = None):
        if self._thread and self._thread.is_alive():
            self.signals.log.emit("Par2Manager already running"); return
        def worker():
            summary = {"groups": len(groups), "results": []}
            try:
                for idx,g in enumerate(groups, start=1):
                    if self._stop_flag: break
                    files, base_name, out_dir = g
                    out_dir = out_dir or default_out_dir
                    self.signals.progress.emit(idx, len(groups))
                    self.signals.log.emit(f"Creating par2 for group {idx}/{len(groups)} files={len(files)} base={base_name} out_dir={out_dir}")
                    res = self._create_single(files, redundancy, base_name=base_name, out_dir=out_dir)
                    summary["results"].append(res)
                self.signals.log.emit("par2 create run complete")
            except Exception as e:
                self.signals.log.emit("par2 manager exception: " + str(e))
                self._append_log(traceback.format_exc())
            finally:
                self.signals.finished.emit(summary)
        self._stop_flag = False
        self._thread = threading.Thread(target=worker, daemon=True)
        self._thread.start()

    def stop(self): self._stop_flag = True

# ---------- Main GUI ----------
class MiniArchGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MiniArch — archive + par2")
        self.resize(1200, 760)
        # small embedded icon (base64 tiny fallback)
        APP_ICON_B64 = ("iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAF0lEQVQoU2Nk"
                        "YGBg+M+ACDAwMPCQAAAwAA+o0Hg3IAAAAASUVORK5CYII=")
        try:
            data = base64.b64decode(APP_ICON_B64)
            pix = QPixmap()
            if pix.loadFromData(data):
                self.setWindowIcon(QIcon(pix))
        except Exception:
            pass

        central = QWidget(); self.setCentralWidget(central)
        layout = QVBoxLayout(central)

        top_row = QHBoxLayout(); layout.addLayout(top_row)
        self.btn_open_archive = QPushButton("Open Archive..."); self.btn_open_archive.clicked.connect(self.slot_open_archive); top_row.addWidget(self.btn_open_archive)
        self.btn_back = QPushButton("Back"); self.btn_back.clicked.connect(self.slot_back); self.btn_back.setEnabled(False); top_row.addWidget(self.btn_back)
        top_row.addStretch()
        self.btn_clear_thumbs = QPushButton("Clear thumbnail cache"); self.btn_clear_thumbs.clicked.connect(self.slot_clear_thumb_cache); top_row.addWidget(self.btn_clear_thumbs)
        self.btn_associate_jarc = QPushButton("Associate .jarc with this script"); self.btn_associate_jarc.clicked.connect(self.slot_associate_jarc); top_row.addWidget(self.btn_associate_jarc)
        self.btn_locate_par2 = QPushButton("Locate par2"); self.btn_locate_par2.clicked.connect(self.slot_locate_par2); top_row.addWidget(self.btn_locate_par2)
        self.btn_search_par2 = QPushButton("Search par2"); self.btn_search_par2.clicked.connect(self.slot_search_par2); top_row.addWidget(self.btn_search_par2)
        self.btn_install_par2 = QPushButton("Install par2 via Chocolatey"); self.btn_install_par2.clicked.connect(self.slot_install_par2_choco); top_row.addWidget(self.btn_install_par2)
        # removed the long par2 label from top_row to avoid overflow; we use status bar instead

        split = QHBoxLayout(); layout.addLayout(split, 1)
        left_col = QVBoxLayout(); split.addLayout(left_col, 3)
        right_col = QVBoxLayout(); split.addLayout(right_col, 1)

        left_col.addWidget(QLabel("Archive contents:"))
        self.list_contents = QListWidget(); self.list_contents.setIconSize(QSize(96,96)); left_col.addWidget(self.list_contents, 1)
        self.list_contents.itemDoubleClicked.connect(self.slot_item_double)
        left_col.addWidget(QLabel("Log:"))
        self.text_log = QTextEdit(); self.text_log.setReadOnly(True); left_col.addWidget(self.text_log, 1)

        right_col.addWidget(QLabel("Create / Stage"))
        self.combo_create_format = QComboBox(); self.combo_create_format.addItems(["zip","7z","jarc"]); right_col.addWidget(self.combo_create_format)
        self.input_create_password = QLineEdit(); self.input_create_password.setEchoMode(QLineEdit.Password); self.input_create_password.setPlaceholderText("Password (blank = none)"); right_col.addWidget(self.input_create_password)
        row_par2_auto = QHBoxLayout(); right_col.addLayout(row_par2_auto)
        self.chk_par2_auto = QCheckBox("Also create .par2 after archive"); row_par2_auto.addWidget(self.chk_par2_auto)
        row_par2_auto.addWidget(QLabel("Redundancy %"))
        self.spin_par2_redundancy = QSpinBox(); self.spin_par2_redundancy.setRange(1,500); self.spin_par2_redundancy.setValue(10); row_par2_auto.addWidget(self.spin_par2_redundancy)

        self.btn_add_stage_files = QPushButton("Add Files"); self.btn_add_stage_files.clicked.connect(self.slot_stage_add_files); right_col.addWidget(self.btn_add_stage_files)
        self.btn_add_stage_folder = QPushButton("Add Folder"); self.btn_add_stage_folder.clicked.connect(self.slot_stage_add_folder); right_col.addWidget(self.btn_add_stage_folder)
        self.list_stage = QListWidget(); right_col.addWidget(self.list_stage, 1)
        row_create = QHBoxLayout(); right_col.addLayout(row_create)
        self.btn_create_archive = QPushButton("Create Archive"); self.btn_create_archive.clicked.connect(self.slot_create_archive); row_create.addWidget(self.btn_create_archive)
        self.btn_create_rar = QPushButton("Create RAR (rar.exe)"); self.btn_create_rar.clicked.connect(self.slot_create_rar); row_create.addWidget(self.btn_create_rar)
        self.btn_create_rar.setEnabled(bool(self.find_rar_exe()))

        right_col.addWidget(QLabel("Par2 Targets (files/folders):"))
        self.list_par2_targets = QListWidget(); right_col.addWidget(self.list_par2_targets, 1)
        row_par2_buttons = QHBoxLayout(); right_col.addLayout(row_par2_buttons)
        self.btn_par2_add_files = QPushButton("Add Files"); self.btn_par2_add_files.clicked.connect(self.slot_par2_add_files); row_par2_buttons.addWidget(self.btn_par2_add_files)
        self.btn_par2_add_folder = QPushButton("Add Folder"); self.btn_par2_add_folder.clicked.connect(self.slot_par2_add_folder); row_par2_buttons.addWidget(self.btn_par2_add_folder)
        row_par2_modes = QHBoxLayout(); right_col.addLayout(row_par2_modes)
        self.radio_par2_one_per = QRadioButton("One .par2 per file/folder"); self.radio_par2_one_per.setChecked(True); row_par2_modes.addWidget(self.radio_par2_one_per)
        self.radio_par2_one_all = QRadioButton("One .par2 for all"); row_par2_modes.addWidget(self.radio_par2_one_all)
        row_par2_action = QHBoxLayout(); right_col.addLayout(row_par2_action)
        self.btn_par2_create_selected = QPushButton("Create .par2 for Selected"); self.btn_par2_create_selected.clicked.connect(self.slot_par2_create_selected); row_par2_action.addWidget(self.btn_par2_create_selected)
        self.btn_par2_create_all = QPushButton("Create .par2 for All"); self.btn_par2_create_all.clicked.connect(self.slot_par2_create_all); row_par2_action.addWidget(self.btn_par2_create_all)

        right_col.addWidget(QLabel("Loaded .par2 files (repair):"))
        self.list_loaded_par2 = QListWidget(); right_col.addWidget(self.list_loaded_par2, 1)
        row_load_par2 = QHBoxLayout(); right_col.addLayout(row_load_par2)
        self.btn_load_par2 = QPushButton("Load .par2 Files"); self.btn_load_par2.clicked.connect(self.slot_load_par2); row_load_par2.addWidget(self.btn_load_par2)
        self.btn_repair_selected = QPushButton("Repair & Move Selected"); self.btn_repair_selected.clicked.connect(self.slot_repair_selected); row_load_par2.addWidget(self.btn_repair_selected)
        self.btn_repair_all = QPushButton("Repair & Move All"); self.btn_repair_all.clicked.connect(self.slot_repair_all); row_load_par2.addWidget(self.btn_repair_all)

        self.progress_bar = QProgressBar(); layout.addWidget(self.progress_bar)

        # Use status bar for par2 path and quick status messages (prevents overlap)
        self.statusBar().showMessage(f"par2: {CFG.get('par2_exe') or 'not found'}")
        self.statusBar().setToolTip("par2 path (use Locate/Search/Install to change)")

        # internal state
        self.current_archive_path: Optional[str] = None
        self.current_archive_format: Optional[str] = None
        self.password_cache: Dict[str, str] = {}
        self.thumb_worker = None
        self.thumb_thread = None
        self.archive_stack: List[Tuple[str, str]] = []
        self.temp_dirs: List[Path] = []

        # ensure repair buttons start disabled
        self.update_par2_buttons()
        # connect signals to update buttons when list changes
        self.list_loaded_par2.model().rowsInserted.connect(lambda *args: self.update_par2_buttons())
        self.list_loaded_par2.model().rowsRemoved.connect(lambda *args: self.update_par2_buttons())

        self._log(f"Init: QT={QT_BINDING}, py7zr={HAS_PY7ZR}, pyzipper={HAS_PYZIPPER}, rarfile={HAS_RARFILE}, pillow={HAS_PIL}")
        self.statusBar().showMessage(f"par2: {CFG.get('par2_exe') or 'not found'}")

    # ---------- small helpers ----------
    def update_par2_buttons(self):
        has = self.list_loaded_par2.count() > 0
        self.btn_repair_selected.setEnabled(has)
        self.btn_repair_all.setEnabled(has)
    def _log(self, s: str):
        ts = time.strftime("%Y-%m-%d %H:%M:%S")
        line = f"{ts} {s}"
        self.text_log.append(line); print(line, flush=True)
        QApplication.processEvents()

    def find_rar_exe(self) -> Optional[str]:
        candidates = [shutil.which("rar"), shutil.which("rar.exe"),
                      r"C:\Program Files\WinRAR\Rar.exe", r"C:\Program Files (x86)\WinRAR\Rar.exe"]
        for c in candidates:
            if c and Path(c).exists():
                return c
        return None

    def ask_password_dialog(self, prompt="Enter password") -> Optional[str]:
        txt, ok = QInputDialog.getText(self, "Password", prompt, QLineEdit.Password)
        if ok and txt:
            return txt
        return None

    # ---------- archive open / listing ----------
    def slot_open_archive(self):
        path, _ = QFileDialog.getOpenFileName(self, "Open archive", filter="Archives (*.zip *.7z *.rar *.jarc);;All files (*)")
        if not path: return
        ext = Path(path).suffix.lower().lstrip('.')
        if ext not in ('zip', '7z', 'rar', 'jarc'):
            QMessageBox.warning(self, "Unsupported", "Supported: zip, 7z, rar, jarc"); return
        if self.current_archive_path:
            self.archive_stack.append((self.current_archive_path, self.current_archive_format or "zip"))
            self.btn_back.setEnabled(True)
        self._load_archive(path, ext)

    def _load_archive(self, path: str, fmt: str):
        self.current_archive_path = path; self.current_archive_format = fmt
        self._log(f"Loading archive: {path}")
        self._list_archive()

    def _zip_has_encrypted(self, path: str) -> bool:
        try:
            with zipfile.ZipFile(path, 'r') as zf:
                for zi in zf.infolist():
                    if getattr(zi, 'flag_bits', 0) & 0x1:
                        return True
        except Exception:
            pass
        return False

    def _list_archive(self):
        self.list_contents.clear()
        if not self.current_archive_path or not self.current_archive_format:
            return
        path = self.current_archive_path; fmt = self.current_archive_format
        members: List[str] = []
        pwd = self.password_cache.get(path)
        try:
            if fmt == 'zip':
                if self._zip_has_encrypted(path) and not pwd:
                    ptry = self.ask_password_dialog(f"ZIP {Path(path).name} looks encrypted. Enter password:")
                    if not ptry: QMessageBox.information(self, "Password required", "Won't list without password"); return
                    self.password_cache[path] = ptry; pwd = ptry
                with zipfile.ZipFile(path, 'r') as zf:
                    members = zf.namelist()
            elif fmt == '7z':
                if not HAS_PY7ZR:
                    raise RuntimeError("py7zr is required to open 7z archives")
                try:
                    with py7zr.SevenZipFile(path, 'r', password=(pwd if pwd else None)) as a:
                        members = a.getnames()
                except Exception:
                    ptry = self.ask_password_dialog(f"7z {Path(path).name} needs a password")
                    if not ptry: QMessageBox.information(self, "Password required", "Won't list without password"); return
                    self.password_cache[path] = ptry; pwd = ptry
                    with py7zr.SevenZipFile(path, 'r', password=pwd) as a:
                        members = a.getnames()
            elif fmt == 'rar':
                if not HAS_RARFILE:
                    raise RuntimeError("rarfile required to open RAR archives")
                try:
                    with rarfile.RarFile(path) as rf:
                        members = rf.namelist()
                except rarfile.NeedPassword:
                    ptry = self.ask_password_dialog(f"RAR {Path(path).name} needs a password")
                    if not ptry: QMessageBox.information(self, "Password required", "Won't list without password"); return
                    self.password_cache[path] = ptry; pwd = ptry
                    with rarfile.RarFile(path) as rf:
                        members = rf.namelist()
                except Exception:
                    ptry = self.ask_password_dialog(f"RAR {Path(path).name} may be encrypted. Enter password:")
                    if not ptry: QMessageBox.information(self, "Password required", "Won't list without password"); return
                    self.password_cache[path] = ptry; pwd = ptry
                    with rarfile.RarFile(path) as rf:
                        members = rf.namelist()
            elif fmt == 'jarc':
                members = [e['name'] for e in read_jarc_manifest(path)]
        except Exception as e:
            self._log(f"List error: {e}\n{traceback.format_exc()}")
            QMessageBox.critical(self, "List error", f"Failed to list archive: {e}")
            return

        image_members = []
        for m in members:
            it = QListWidgetItem(m)
            if m.endswith('/') or m.endswith('\\'):
                it.setIcon(QApplication.style().standardIcon(QStyle.SP_DirIcon))
            else:
                ext = Path(m).suffix.lower()
                if ext in IMAGE_EXTS:
                    it.setIcon(QApplication.style().standardIcon(QStyle.SP_FileIcon))
                    image_members.append(m)
                else:
                    it.setIcon(get_system_icon_for_ext(ext or ".txt"))
            self.list_contents.addItem(it)

        if image_members:
            self._start_thumb_worker(image_members)

    # ---------- thumbnails ----------
    def _start_thumb_worker(self, names: List[str]):
        try:
            if self.thumb_worker and self.thumb_thread:
                self.thumb_worker.stop()
                self.thumb_thread.quit(); self.thumb_thread.wait(200)
        except Exception:
            pass
        pwd = self.password_cache.get(self.current_archive_path)
        self.thumb_worker = ThumbWorker(self.current_archive_path, self.current_archive_format, names, password=pwd)
        self.thumb_thread = QThread()
        self.thumb_worker.moveToThread(self.thumb_thread)
        self.thumb_thread.started.connect(self.thumb_worker.run)
        self.thumb_worker.thumb_ready.connect(self._on_thumb_ready)
        self.thumb_worker.log.connect(lambda s: self._log("Thumb: " + s))
        self.thumb_worker.finished.connect(self._on_thumb_finished)
        self.thumb_thread.start()

    def _on_thumb_ready(self, entry_name: str, cache_path: str):
        for i in range(self.list_contents.count()):
            it = self.list_contents.item(i)
            if it.text() == entry_name:
                try:
                    pix = QPixmap(cache_path)
                    if not pix.isNull():
                        it.setIcon(QIcon(pix.scaled(96,96, Qt.KeepAspectRatio, Qt.SmoothTransformation)))
                except Exception as e:
                    self._log(f"Thumb display error: {e}")

    def _on_thumb_finished(self):
        self._log("Thumbnail worker finished")
        try:
            if self.thumb_thread:
                self.thumb_thread.quit(); self.thumb_thread.wait(200)
        except Exception:
            pass

    def slot_clear_thumb_cache(self):
        removed = 0
        for f in THUMB_CACHE.iterdir():
            if f.is_file() and f.suffix.lower() == ".png":
                try:
                    f.unlink(); removed += 1
                except Exception:
                    pass
        self._log(f"Cleared {removed} thumbnails")

    # ---------- open / nested ----------
    def slot_item_double(self, item: QListWidgetItem):
        member = item.text()
        ext = Path(member).suffix.lower().lstrip('.')
        if ext in ('zip', '7z', 'rar', 'jarc'):
            tmpd = Path(tempfile.mkdtemp(prefix="miniarch_nested_")); self.temp_dirs.append(tmpd)
            extracted_path = self._extract_member_to_temp(member, tmpd)
            if extracted_path:
                if self.current_archive_path:
                    self.archive_stack.append((self.current_archive_path, self.current_archive_format or "zip"))
                    self.btn_back.setEnabled(True)
                self._load_archive(str(extracted_path), ext)
            else:
                QMessageBox.warning(self, "Open nested", "Could not extract nested archive")
        else:
            tmpd = Path(tempfile.mkdtemp(prefix="miniarch_open_")); self.temp_dirs.append(tmpd)
            extracted_path = self._extract_member_to_temp(member, tmpd)
            if extracted_path and extracted_path.exists():
                self._open_path_with_system(extracted_path)
            else:
                found = None
                for p in tmpd.rglob("*"):
                    if p.is_file() and p.name == Path(member).name:
                        found = p; break
                if found:
                    self._open_path_with_system(found)
                else:
                    QMessageBox.warning(self, "Open", "Could not extract/open member")

    def _open_path_with_system(self, p: Path):
        try:
            if p.is_dir():
                if ON_WINDOWS:
                    os.startfile(str(p))
                else:
                    subprocess.run(["xdg-open", str(p)], check=False)
            else:
                if ON_WINDOWS:
                    os.startfile(str(p))
                else:
                    subprocess.run(["xdg-open", str(p)], check=False)
        except Exception as e:
            self._log(f"Open error: {e}")
            QMessageBox.warning(self, "Open", f"Failed to open file: {e}")

    def _extract_member_to_temp(self, member: str, tmpdir: Path) -> Optional[Path]:
        if not self.current_archive_path:
            return None
        fmt = self.current_archive_format; path = self.current_archive_path; pwd = self.password_cache.get(path)
        try:
            if fmt == 'zip':
                with zipfile.ZipFile(path, 'r') as zf:
                    candidate=None
                    if member in zf.namelist():
                        candidate=member
                    else:
                        for nm in zf.namelist():
                            if Path(nm).name == Path(member).name:
                                candidate = nm; break
                    if not candidate: return None
                    try:
                        if pwd: zf.extract(candidate, path=str(tmpdir), pwd=pwd.encode())
                        else: zf.extract(candidate, path=str(tmpdir))
                        return Path(tmpdir) / candidate
                    except RuntimeError:
                        pwd_try = self.ask_password_dialog(f"ZIP needs password for {Path(path).name}")
                        if not pwd_try: return None
                        self.password_cache[path] = pwd_try; zf.extract(candidate, path=str(tmpdir), pwd=pwd_try.encode()); return Path(tmpdir)/candidate
            elif fmt == '7z':
                if not HAS_PY7ZR:
                    raise RuntimeError("py7zr required")
                try:
                    with py7zr.SevenZipFile(path, 'r', password=(pwd if pwd else None)) as a:
                        names = a.getnames(); target=None
                        for n in names:
                            if n == member or Path(n).name == Path(member).name:
                                target=n; break
                        if not target: return None
                        a.extract(targets=[target], path=str(tmpdir)); return Path(tmpdir)/target
                except Exception:
                    pwd_try = self.ask_password_dialog(f"7z needs password for {Path(path).name}")
                    if not pwd_try: return None
                    self.password_cache[path] = pwd_try
                    with py7zr.SevenZipFile(path, 'r', password=pwd_try) as a:
                        names=a.getnames(); target=None
                        for n in names:
                            if n==member or Path(n).name==Path(member).name: target=n; break
                        if not target: return None
                        a.extract(targets=[target], path=str(tmpdir)); return Path(tmpdir)/target
            elif fmt == 'rar':
                if not HAS_RARFILE: raise RuntimeError("rarfile required")
                with rarfile.RarFile(path) as rf:
                    names=rf.namelist(); target=None
                    for n in names:
                        if n==member or Path(n).name==Path(member).name: target=n; break
                    if not target: return None
                    try:
                        rf.extract(target, path=str(tmpdir), pwd=(pwd if pwd else None))
                    except rarfile.BadRarFile:
                        pwd_try=self.ask_password_dialog(f"RAR needs password for {Path(path).name}")
                        if not pwd_try: return None
                        self.password_cache[path]=pwd_try; rf.extract(target, path=str(tmpdir), pwd=pwd_try)
                    except Exception:
                        pwd_try=self.ask_password_dialog(f"RAR may require password for {Path(path).name}")
                        if not pwd_try: return None
                        self.password_cache[path]=pwd_try; rf.extract(target, path=str(tmpdir), pwd=pwd_try)
                    return Path(tmpdir)/target
            elif fmt == 'jarc':
                data = extract_jarc_member_bytes(path, member); outp = tmpdir / Path(member).name; outp.parent.mkdir(parents=True, exist_ok=True); outp.write_bytes(data); return outp
        except Exception as e:
            self._log(f"extract_member_to_temp error: {e}\n{traceback.format_exc()}")
            return None

    # ---------- back ----------
    def slot_back(self):
        if not self.archive_stack:
            self.btn_back.setEnabled(False); return
        prev = self.archive_stack.pop()
        if not self.archive_stack:
            self.btn_back.setEnabled(False)
        self._load_archive(prev[0], prev[1])

    # ---------- stage/create ----------
    def slot_stage_add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Select files")
        for f in files: self.list_stage.addItem(QListWidgetItem(f))

    def slot_stage_add_folder(self):
        d = QFileDialog.getExistingDirectory(self, "Select folder")
        if d: self.list_stage.addItem(QListWidgetItem(d))

    def slot_create_archive(self):
        if self.list_stage.count() == 0:
            QMessageBox.information(self, "No files", "Stage files/folders first"); return
        fmt = self.combo_create_format.currentText(); out, _ = QFileDialog.getSaveFileName(self, "Save archive as", filter=f"{fmt.upper()} (*.{fmt})")
        if not out: return
        if not out.lower().endswith("." + fmt): out += "." + fmt
        items = [self.list_stage.item(i).text() for i in range(self.list_stage.count())]
        password = self.input_create_password.text().strip()
        try:
            if fmt == 'zip':
                if password:
                    if not HAS_PYZIPPER:
                        QMessageBox.critical(self, "pyzipper missing", "pyzipper is required to create password-protected ZIPs. Install: pip install pyzipper"); return
                    with pyzipper.AESZipFile(out, 'w', compression=pyzipper.ZIP_DEFLATED, encryption=pyzipper.WZ_AES) as zf:
                        zf.setpassword(password.encode())
                        for p in items:
                            pth = Path(p)
                            if pth.is_dir():
                                parent = pth.parent
                                for root, _, fnames in os.walk(pth):
                                    for f in fnames:
                                        full = Path(root) / f; arc = str(full.relative_to(parent)).replace("\\","/")
                                        zf.write(str(full), arcname=arc)
                            else:
                                zf.write(str(pth), arcname=pth.name)
                else:
                    with zipfile.ZipFile(out, 'w', compression=zipfile.ZIP_DEFLATED) as zf:
                        for p in items:
                            pth = Path(p)
                            if pth.is_dir():
                                parent = pth.parent
                                for root, _, fnames in os.walk(pth):
                                    for f in fnames:
                                        full=Path(root)/f; arc = str(full.relative_to(parent)).replace("\\","/")
                                        zf.write(str(full), arcname=arc)
                            else:
                                zf.write(str(pth), arcname=pth.name)
            elif fmt == '7z':
                if not HAS_PY7ZR:
                    QMessageBox.critical(self, "py7zr missing", "py7zr required for 7z creation."); return
                if password:
                    with py7zr.SevenZipFile(out, 'w', password=password) as a:
                        for p in items:
                            pth = Path(p)
                            if pth.is_dir(): a.writeall(str(pth), arcname=pth.name)
                            else: a.write(str(pth), arcname=pth.name)
                else:
                    with py7zr.SevenZipFile(out, 'w') as a:
                        for p in items:
                            pth = Path(p)
                            if pth.is_dir(): a.writeall(str(pth), arcname=pth.name)
                            else: a.write(str(pth), arcname=pth.name)
            elif fmt == 'jarc':
                create_jarc(out, items, compress=True)
            self._log(f"Created {out}")
            QMessageBox.information(self, "Created", f"Archive created: {out}")
            if self.chk_par2_auto.isChecked():
                par2_red = int(self.spin_par2_redundancy.value())
                mgr = Par2Manager(par2_exe=CFG.get("par2_exe"))
                if not mgr.is_ok():
                    QMessageBox.information(self, "par2 missing", "par2 not configured. Use Locate/Search/Install tools.")
                else:
                    groups = [([out], None, None)]
                    mgr.signals.log.connect(lambda s: self._log("par2: " + s))
                    mgr.signals.progress.connect(lambda cur, tot: self.progress_bar.setValue(int((cur / tot) * 100)))
                    def on_finished(summary): self._log("par2 create finished"); self.progress_bar.setValue(0); QMessageBox.information(self, "par2 create", "par2 creation finished.")
                    mgr.signals.finished.connect(on_finished)
                    mgr.run_create(groups, par2_red, out_dir=None)
        except Exception as e:
            self._log(f"Create error: {e}\n{traceback.format_exc()}")
            QMessageBox.critical(self, "Create error", str(e))

    def slot_create_rar(self):
        rar = self.find_rar_exe()
        if not rar:
            QMessageBox.critical(self, "rar missing", "rar.exe not found"); return
        out, _ = QFileDialog.getSaveFileName(self, "Save RAR as", filter="RAR (*.rar)")
        if not out: return
        if not out.lower().endswith(".rar"): out += ".rar"
        items = [self.list_stage.item(i).text() for i in range(self.list_stage.count())]
        if not items:
            QMessageBox.information(self, "No files", "Stage files first"); return
        password = self.input_create_password.text().strip()
        cmd = [rar, 'a', '-ep1']
        if password: cmd.append(f"-hp{password}")
        cmd.append(out); cmd += items
        try:
            rc, outb, errb = safe_run(cmd, timeout=600)
            if rc == 0:
                self._log(f"RAR created: {out}"); QMessageBox.information(self, "RAR created", f"RAR created: {out}")
            else:
                self._log(f"RAR create failed: rc={rc}, out={outb[:200]}, err={errb[:200]}")
                QMessageBox.warning(self, "RAR create", "RAR creation returned non-zero (see log)")
        except Exception as e:
            self._log(f"RAR create error: {e}"); QMessageBox.critical(self, "RAR create error", str(e))

    # ---------- par2 target area ----------
    def slot_par2_add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Add files to par2 targets")
        for f in files: self.list_par2_targets.addItem(QListWidgetItem(f))
        self._log(f"Added {len(files)} file targets")

    def _expand_folder_to_files(self, folder_path: str) -> List[str]:
        out = []
        for root, _, files in os.walk(folder_path):
            for fn in files:
                full = os.path.join(root, fn); out.append(full)
        return out

    def slot_par2_add_folder(self):
        d = QFileDialog.getExistingDirectory(self, "Add folder to par2 targets (won't expand on add)")
        if not d: return
        self.list_par2_targets.addItem(QListWidgetItem(d))
        self._log(f"Added folder target: {d}")

    def slot_par2_create_selected(self):
        selected = [self.list_par2_targets.item(i).text() for i in range(self.list_par2_targets.count()) if self.list_par2_targets.item(i).isSelected()]
        if not selected: QMessageBox.information(self, "No selection", "Select targets"); return
        redundancy = int(self.spin_par2_redundancy.value())
        mgr = Par2Manager(par2_exe=CFG.get("par2_exe"))
        if not mgr.is_ok(): QMessageBox.information(self, "par2 missing", "par2 not configured. Use Locate/Search/Install"); return
        groups=[]
        if self.radio_par2_one_per.isChecked():
            for t in selected:
                if os.path.isdir(t):
                    files = self._expand_folder_to_files(t)
                    if files: groups.append((files, Path(t).name, t))
                else:
                    groups.append(([t], None, None))
        else:
            all_files=[]
            for t in selected:
                if os.path.isdir(t): all_files += self._expand_folder_to_files(t)
                else: all_files.append(t)
            if not all_files: QMessageBox.information(self, "No files", "No files found"); return
            out_dir = QFileDialog.getExistingDirectory(self, "Where to write the .par2 file (directory)")
            if not out_dir: QMessageBox.information(self, "Output required", "Choose an output directory"); return
            base_name, ok = QInputDialog.getText(self, "Base name", "Enter base name for .par2 (without extension):", QLineEdit.Normal, "archive_par2")
            if not ok: base_name=None
            groups.append((all_files, base_name or None, out_dir))
        mgr.signals.log.connect(lambda s: self._log("par2: " + s))
        mgr.signals.progress.connect(lambda cur, tot: self.progress_bar.setValue(int((cur / tot) * 100)))
        def on_finished(summary): self._log("par2 create finished"); self.progress_bar.setValue(0)
        mgr.signals.finished.connect(on_finished)
        mgr.run_create(groups, redundancy, default_out_dir=None)

    def slot_par2_create_all(self):
        items = [self.list_par2_targets.item(i).text() for i in range(self.list_par2_targets.count())]
        if not items: QMessageBox.information(self, "No targets", "Add targets first"); return
        redundancy = int(self.spin_par2_redundancy.value())
        mgr = Par2Manager(par2_exe=CFG.get("par2_exe"))
        if not mgr.is_ok(): QMessageBox.information(self, "par2 missing", "par2 not configured. Use Locate/Search/Install"); return
        groups=[]
        if self.radio_par2_one_per.isChecked():
            seen=set()
            for t in items:
                if os.path.isdir(t):
                    if t in seen: continue
                    seen.add(t)
                    files = self._expand_folder_to_files(t)
                    if files: groups.append((files, Path(t).name, t))
                else:
                    groups.append(([t], None, None))
        else:
            all_files=[]
            for t in items:
                if os.path.isdir(t): all_files += self._expand_folder_to_files(t)
                else: all_files.append(t)
            if not all_files: QMessageBox.information(self, "No files", "No files to include"); return
            out_dir = QFileDialog.getExistingDirectory(self, "Where to write the .par2 file (directory)")
            if not out_dir: QMessageBox.information(self, "Output required", "Choose an output directory"); return
            base_name, ok = QInputDialog.getText(self, "Base name", "Enter base name for .par2 (without extension):", QLineEdit.Normal, "all_par2")
            if not ok: base_name=None
            groups.append((all_files, base_name or None, out_dir))
        mgr.signals.log.connect(lambda s: self._log("par2: " + s))
        mgr.signals.progress.connect(lambda cur, tot: self.progress_bar.setValue(int((cur / tot) * 100)))
        mgr.signals.finished.connect(lambda summary: (self._log("par2 create finished"), self.progress_bar.setValue(0)))
        mgr.run_create(groups, redundancy, default_out_dir=None)

    # ---------- par2 repair/load ----------
    def slot_load_par2(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Load .par2 files", filter="par2 files (*.par2);;All files (*)")
        if not files:
            return
        self.list_loaded_par2.clear()
        for f in files: self.list_loaded_par2.addItem(QListWidgetItem(f))
        self._log(f"Loaded {len(files)} .par2 files")
        self.update_par2_buttons()

    def slot_repair_selected(self):
        items = [self.list_loaded_par2.item(i).text() for i in range(self.list_loaded_par2.count()) if self.list_loaded_par2.item(i).isSelected()]
        if not items:
            # no selection: either prompt to load or inform
            resp = QMessageBox.question(self, "No selection", "No .par2 selected. Load .par2 files now?", QMessageBox.Yes | QMessageBox.No)
            if resp == QMessageBox.Yes:
                self.slot_load_par2(); items = [self.list_loaded_par2.item(i).text() for i in range(self.list_loaded_par2.count()) if self.list_loaded_par2.item(i).isSelected()]
            if not items:
                return
        dest = QFileDialog.getExistingDirectory(self, "Move repaired files to folder (optional)")
        mgr = Par2Manager(par2_exe=CFG.get("par2_exe"))
        if not mgr.is_ok(): QMessageBox.information(self, "par2 missing", "par2 not configured. Use Locate/Search/Install"); return
        mgr.signals.log.connect(lambda s: self._log("par2: " + s))
        mgr.signals.progress.connect(lambda cur, tot: self.progress_bar.setValue(int((cur/tot)*100)))
        def on_finished(summary):
            self._log("par2 repair finished"); self.progress_bar.setValue(0)
            moved=[]
            for r in summary.get("results", []):
                moved += r.get("moved", []) or []
            if moved:
                QMessageBox.information(self, "Repair done", "Moved repaired files:\n" + "\n".join(moved))
            else:
                QMessageBox.information(self, "Repair done", "Repair finished (see log).")
        mgr.signals.finished.connect(on_finished)
        mgr.run_repair_many(items, move_repaired_to=dest if dest else None)

    def slot_repair_all(self):
        # If nothing loaded, offer to auto-scan a folder or load files
        all_items = [self.list_loaded_par2.item(i).text() for i in range(self.list_loaded_par2.count())]
        if not all_items:
            resp = QMessageBox.question(self, "No .par2 loaded",
                                        "No .par2 files are loaded. Would you like to:\n\n"
                                        "Yes = Scan a folder for .par2 files\nNo = Pick .par2 files to load\nCancel = do nothing",
                                        QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)
            if resp == QMessageBox.Yes:
                folder = QFileDialog.getExistingDirectory(self, "Select folder to scan for .par2 files")
                if not folder:
                    return
                found = []
                for root, _, files in os.walk(folder):
                    for fn in files:
                        if fn.lower().endswith(".par2"):
                            found.append(os.path.join(root, fn))
                if not found:
                    QMessageBox.information(self, "No .par2", f"No .par2 files found under {folder}")
                    return
                self.list_loaded_par2.clear()
                for f in found:
                    self.list_loaded_par2.addItem(QListWidgetItem(f))
                self._log(f"Auto-loaded {len(found)} .par2 files from {folder}")
            elif resp == QMessageBox.No:
                self.slot_load_par2()
                all_items = [self.list_loaded_par2.item(i).text() for i in range(self.list_loaded_par2.count())]
                if not all_items:
                    return
            else:
                return
        # after ensuring list has items, proceed
        items = [self.list_loaded_par2.item(i).text() for i in range(self.list_loaded_par2.count())]
        if not items:
            QMessageBox.information(self, "No .par2", "No .par2 files found/loaded"); return
        dest = QFileDialog.getExistingDirectory(self, "Move repaired files to folder (optional)")
        mgr = Par2Manager(par2_exe=CFG.get("par2_exe"))
        if not mgr.is_ok(): QMessageBox.information(self, "par2 missing", "par2 not configured. Use Locate/Search/Install"); return
        mgr.signals.log.connect(lambda s: self._log("par2: " + s))
        mgr.signals.progress.connect(lambda cur, tot: self.progress_bar.setValue(int((cur/tot)*100)))
        def on_finished(summary):
            self._log("par2 repair finished"); self.progress_bar.setValue(0)
            moved=[]
            for r in summary.get("results", []):
                moved += r.get("moved", []) or []
            if moved:
                QMessageBox.information(self, "Repair done", "Moved repaired files:\n" + "\n".join(moved))
            else:
                QMessageBox.information(self, "Repair done", "Repair finished (see log).")
        mgr.signals.finished.connect(on_finished)
        mgr.run_repair_many(items, move_repaired_to=dest if dest else None)
        self.update_par2_buttons()

    # ---------- par2 locate/search/install ----------
    def slot_locate_par2(self):
        path, _ = QFileDialog.getOpenFileName(self, "Locate par2 executable", filter="Executables (*.exe);;All files (*)")
        if not path: return
        try:
            rc, out, err = safe_run([path, "--version"], timeout=3)
            if rc == 0 or out or err:
                CFG["par2_exe"] = path; save_cfg(CFG)
                self.statusBar().showMessage(f"par2: {path}")
                QMessageBox.information(self, "par2", f"par2 configured: {path}"); return
        except Exception:
            pass
        QMessageBox.warning(self, "par2", "Selected file doesn't look like par2")

    def slot_search_par2(self):
        found = self._search_common_par2_locations()
        if found:
            CFG["par2_exe"] = found; save_cfg(CFG); self.statusBar().showMessage(f"par2: {found}"); QMessageBox.information(self, "Found", f"par2 found: {found}")
        else:
            QMessageBox.information(self, "Not found", "No par2 found in common locations")

    def _search_common_par2_locations(self) -> Optional[str]:
        cand=[]
        if ON_WINDOWS:
            pf=os.getenv("PROGRAMFILES", r"C:\Program Files"); pf86=os.getenv("PROGRAMFILES(X86)", r"C:\Program Files (x86)")
            cand += [os.path.join(pf,"par2","par2.exe"), os.path.join(pf86,"par2","par2.exe"),
                     os.path.join(pf,"par2cmdline","par2.exe"), os.path.join(pf86,"par2cmdline","par2.exe"),
                     os.path.join(os.getenv("ProgramData", r"C:\ProgramData"), "chocolatey", "bin", "par2.exe")]
            for p in os.environ.get("PATH","").split(os.pathsep):
                cand.append(os.path.join(p,"par2.exe"))
        else:
            for p in os.environ.get("PATH","").split(os.pathsep):
                cand.append(os.path.join(p,"par2"))
        tried=set()
        for c in cand:
            if not c or c in tried: continue
            tried.add(c)
            try:
                if Path(c).exists():
                    rc,out,err = safe_run([c,"--version"], timeout=3)
                    if rc==0 or out or err:
                        return c
            except Exception:
                pass
        return None

    def slot_install_par2_choco(self):
        if not ON_WINDOWS or shutil.which("choco") is None:
            QMessageBox.information(self, "Chocolatey missing", "Chocolatey not found in PATH. Install Chocolatey first or use Locate par2."); return
        resp = QMessageBox.question(self, "Install par2 via Chocolatey", "Install par2cmdline via Chocolatey? This requires admin.", QMessageBox.Yes | QMessageBox.No)
        if resp != QMessageBox.Yes: return
        cmd = ["choco", "install", "par2cmdline", "-y", "--no-progress"]
        self._log(f"Running: {' '.join(cmd)}")
        rc,out,err = safe_run(cmd, timeout=600)
        if rc==0:
            found = self._search_common_par2_locations()
            if found:
                CFG["par2_exe"]=found; save_cfg(CFG); self.statusBar().showMessage(f"par2: {found}"); QMessageBox.information(self, "Installed", f"par2 installed and configured: {found}")
            else:
                QMessageBox.information(self, "Installed", "par2 installed but not found automatically. Use Locate par2.")
        else:
            self._log(f"choco install rc={rc} out={out[:200]} err={err[:200]}")
            QMessageBox.information(self, "Install failed", f"Install returned rc={rc}. See log.")

    # ---------- Associate .jarc (Windows HKCU helper) ----------
    def slot_associate_jarc(self):
        if not ON_WINDOWS or winreg is None:
            QMessageBox.information(self, "Not supported", "Association helper only supported on Windows.")
            return
        script_default = os.path.abspath(sys.argv[0])
        python_exec = sys.executable
        script_path, _ = QFileDialog.getOpenFileName(self, "Select script or exe to associate .jarc with", script_default)
        if not script_path: return
        cmd = f'"{python_exec}" "{script_path}" "%1"'
        try:
            base = r"Software\\Classes"
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, base, 0, winreg.KEY_WRITE) as hk:
                with winreg.CreateKey(hk, ".jarc") as k:
                    winreg.SetValueEx(k, "", 0, winreg.REG_SZ, "MiniArch.jarc")
                with winreg.CreateKey(hk, "MiniArch.jarc") as prog:
                    winreg.SetValueEx(prog, "", 0, winreg.REG_SZ, "MiniArch JARC File")
                    with winreg.CreateKey(prog, "DefaultIcon") as di:
                        winreg.SetValueEx(di, "", 0, winreg.REG_SZ, "")
                    with winreg.CreateKey(prog, r"shell\open\command") as cmdk:
                        winreg.SetValueEx(cmdk, "", 0, winreg.REG_SZ, cmd)
            QMessageBox.information(self, "Associated", f".jarc associated with:\n{cmd}\n(You may need to log out/in or use 'Open with...' to set default.)")
            self._log(f".jarc associated with {cmd}")
        except Exception as e:
            self._log("Association failed: " + str(e))
            QMessageBox.critical(self, "Association failed", str(e))

    # ---------- cleanup ----------
    def closeEvent(self, event):
        try:
            if self.thumb_worker and self.thumb_thread:
                self.thumb_worker.stop()
                self.thumb_thread.quit(); self.thumb_thread.wait(200)
        except Exception:
            pass
        for d in self.temp_dirs:
            try: shutil.rmtree(str(d), ignore_errors=True)
            except Exception: pass
        event.accept()

# ---------- entry ----------
def main():
    app = QApplication(sys.argv)
    win = MiniArchGUI()
    win.showMaximized()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
